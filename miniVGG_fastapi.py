from fastapi import FastAPI
from pydantic import BaseModel
from typing import Optional
from imutils import paths
from sklearn.model_selection import train_test_split, RandomizedSearchCV, RepeatedKFold
from sklearn.metrics import classification_report
from tensorflow.keras.optimizers import SGD
from sklearn.preprocessing import LabelBinarizer

from toolbox.tf.nn.conv.miniVGGNet import MiniVGGNet
from toolbox.loading.simple_dataset_loader import SimpleDatasetLoader
from toolbox.preprocessing.simple_preprocessor import SimplePreprocessor
from config import PKL_PATH, EPOCHS

import numpy as np
import os


app = FastAPI()


class MiniVGGTrainRequest(BaseModel):
    # this is a value auto-generated by the master node
    # It represents the ID of the current training job
    taskId: str 
    # This value will determite if a testing set is needed to be set aside 
    # for scoring. By default it is False, which means a test set should 
    # be set aside for scoring
    trainOnly: Optional[bool] = False
    # This is a string that represents the path to the training data
    dataset: str

class MiniVGGTrainResponse(BaseModel):
    # This is the same taskId that was sent to this container by the master node
    taskId: str
    # This is the path to which the pickled model is saved
    modelPath: str
    # This is the score representing the model's performance
    accuracy: float
    # This is a long string representing the classification report 
    # of the resulting model
    classificationReport: str

@app.post("/train")
def train(request: MiniVGGTrainRequest) -> dict:
    print("[INFO] Received MiniVGG Training Request")
    # initialize the local binary patterns descriptor along with the data and label lists
    dataset = request.dataset
    print(f"[INFO] Dataset Received For Training: {dataset.split(os.path.sep)[-1]}")
    taskId = request.taskId
    trainOnly = request.trainOnly

    imagePaths = list(paths.list_images(dataset))
    preprocessor = SimplePreprocessor(128, 128)
    loader = SimpleDatasetLoader(preprocessors=[ preprocessor ])
    (images, imageLabels) = loader.load(imagePaths)

    images = images.astype("float") / 255.0
    lb = LabelBinarizer()
    labels = lb.fit_transform(imageLabels)

    print("[INFO] Preparing Training Data")
    if trainOnly:
        trainImages = images
        # no need to set aside a test set
        testImages = np.array([])
    else:
        (trainImages, testImages, trainLabels, testLabels) = train_test_split(images, labels, test_size=0.25)

    print("[INFO] Fitting Model")
    optimizer = SGD(learning_rate=0.01, weight_decay=0.01/EPOCHS, momentum=0.9, nesterov=True)
    model = MiniVGGNet.build(128,  128, 3, num_classes=len(np.unique(imageLabels)))
    model.compile(loss="categorical_crossentropy", optimizer=optimizer, metrics=["accuracy"])
    model.fit(trainImages, trainLabels)
    print("[INFO] Model Fitting Complete")

    if trainOnly:
        print("[INFO] Testing Not Required. Proceeding To Response Preparation")
        testImages = trainImages
        testLabels = trainLabels
        # get predictions of the training set to use for the classification report
        predictions = model.predict(np.array( testImages ))
        uniqueLabels = np.unique(testLabels)

    else:
        print("[INFO] Preparing Testing Data")

        # Similar to the training set, load each image and perform a 
        # prediction on them to see what the model thinks it is
        # This prediction will be recorded for scoring later
        predictions = model.predict(testImages)
        uniqueLabels = np.unique(labels)

    print("[INFO] Scoring Model")
    accuracy = model.evaluate(testImages, testLabels)
    classificationReport = classification_report(testLabels.argmax(axis=1), predictions.argmax(axis=1), labels=uniqueLabels)
    print("[INFO] Train Request Complete, Returning Training Results")

    print("[INFO] Saving Trained Model")
    modelPath = os.path.join(PKL_PATH, taskId + ".hdf5")
    model.save(modelPath)
    print("[INFO] Training Model Saved")

    print({"taskId": taskId, "modelPath": modelPath, "accuracy": accuracy, 
             "classificationReport": classificationReport})

    return {"taskId": taskId, "modelPath": modelPath, "accuracy": accuracy, 
             "classificationReport": classificationReport}
